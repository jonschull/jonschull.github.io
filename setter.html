<html>
<head>
    <script type="text/javascript"  src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script type="text/javascript"  src="https://cdn.jsdelivr.net/npm/brython@3.9.0/brython.min.js">     </script>
    <script type="text/javascript"  src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.8.8/brython_stdlib.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.min.js" type="text/javascript" charset="utf-8"></script>
    <link type="text/css" rel="stylesheet" href="splicerStyles.css">
    <link type="text/css" rel="stylesheet" href="sliderStyles.css">

</head>
<body onload="brython()">
    <script type="text/python">
    from browser import document, html, aio, window, load
    from browser.local_storage import storage
    from javascript import JSON, jsobj2pyobj
    from browser.html import *
    STARTING=True

    #filename and graphString are GLOBAL
    #...index.html?filename=whatever
    filename =  document.query.getfirst('filename') or ''
    graphString = 'LABEL Welcome!'

    ### print and errors will go to console (unless Brython fails)
    def redirectOutputs():
        document <= DIV(PRE(ID='console',  contenteditable='true'))
        import sys
        class MyOutput:
            def __init__(self):
                self.console = document["console"]
            def write(self, text):
                self.console.html +=  text + '</hr>'
        sys.stdout = MyOutput()
        sys.stderr = MyOutput()
    redirectOutputs()

    document <= DIV(
            TABLE(  THEAD(TR( TH('ShortHands')
                            +TH('Filename '
                                + INPUT(filename, id='filename', value=filename)
                                + BUTTON('Save', id='Save')
                                + SPAN(id='status')
                                + BUTTON('Load', id='Load') )
                            +TH(BUTTON('center', id='Center')
                                +'Diagram'
                                +BR()
                                +BUTTON('Store Positions', id='storePositions')
                                +BUTTON('Load Positions', id='loadPositions')
                            )
                            +TH(BUTTON('Toggle Options ', id='toggle') + 'tweaker'
                                +BR()
                                +BUTTON('layout', id='layout')
                                +BUTTON('nodes', id='nodes')
                                +BUTTON('edges', id='edges')
                                +BUTTON('physics', id='physics')
                                ))
                        )
                        +TR (TD('Shorthands!!!',ID='SHORTHANDS',   contenteditable='true')
                            +TD('Text goes here!!!',ID='LEFT',  contenteditable='true')
                            +TD(DIV('goes here', id="mynetwork"))
                            +TD('tweaker',id='tweaker')
                        ),
                            Class='fixed-headers'),

                    Class='table-scroll')

    window.ace.config.set('basePath', 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/');
    editor = window.ace.edit("SHORTHANDS");
    editor.setOptions({
            'showLineNumbers':False,
            'showInvisibles': True,
            'useSoftTabs': False})
    editor.session.setMode("ace/mode/yaml");


    def loadFileName(ev):
        """localStorage/filename -> LEFT
           localStorage/filename.short -> SHORTHANDS
           BUG:
        """
        global filename
        filename = document['filename'].value
        if not filename or not (filename in storage):
            print('AVAILABLE FILES')
            print([key for key in storage if not key.endswith('.short')])
            return

        if filename + '.short' in storage:
            shortHands= storage[filename + '.short']
            editor.setValue(shortHands)

        document['status'].text = '  loaded'

        graphString = storage[filename]
        fillLEFT(graphString)

        onEdit(ev)
    document['Load'].bind('click', loadFileName)

    def saveFileName(ev):
        global filename
        filename = document['filename'].value
        #print(window.Date.now(), 'saving  to', filename,':\n', document['LEFT'].text)
        storage[filename] = document['LEFT'].text

        shortHands = editor.getValue()    ;  storage[filename+'.short'] = shortHands

        document['status'].text = '  saved'
    document['Save'].bind('click', saveFileName)

    from imports.nodeStuff import dataAndOptions, getNodes, parseOptions


    def refreshGraph(graphString='a:b\n',modifiedOptions=None, modifiedData=None):
        data, options = dataAndOptions(graphString) #Fix: this is not needed if modifiedNodes AND modified Options
        data['nodes'] = window.vis.DataSet.new(data['nodes'])
        data['edges'] = window.vis.DataSet.new(data['edges'])

        options = modifiedOptions or options
        #options['layout']['improvedLayout']= False
        #options['edges']['smooth']=False
        #options['physics'] = True
        options['configure']['container'] = document['tweaker']
        POs = parseOptions(graphString)
        for po in POs.keys():
            options[po] = POs[po]

        data = modifiedData or data
        document['tweaker'].html = ''
        network = window.vis.Network.new(document['mynetwork'], data, options)
        return (data, options, network)

    data, options, network = refreshGraph(graphString)

    def networkClick(params): #bound via network.on below
        print('networkClick', params.nodes)
        if params.nodes:
            ID=params.nodes[0]
            URL = [node['url'] for node in nodes if node['id'] == ID][0]
            print('URL', URL)
            if URL:
                document['LEFT'].html = URL; # for a moment,
                aio.run(showFile(URL))       # until this finishes
    network.on("click", networkClick);

    async def showFile(src): #works locally and via server
        # Text file
        req = await aio.ajax("GET", src)
        print('showFile', src, req.statusText)
        if req.statusText == 'OK':
            content = JSON.parse(req.data)['content']
            #document['LEFT'].html = content
            fillLEFT(content)

    def onEdit(ev):
        global data, options, network, graphString
        document['status'].text = 'changed'
        #graphString = document['LEFT'].text
        data, options, network = refreshGraph(graphString)
        network.on("click", networkClick)  #rebuilt network, so rebuild click
        network.on('configChange', configChange)
        #print('onEdit data', data)
    document['LEFT'].bind('input',onEdit)


    def niceRep(preNode, goodKeys = 'ID LABEL LINKTO PARENT ADDENDA'.split(' ')):
        ret=[]
        for k,v in preNode.items():
            if k in goodKeys:
                ret.append(f'{k} {v}')
        return '/' + '  /'.join(ret)

    def newNode(line):
        return dict( ID=None,
                        DEPTH = len(line) - len(line.lstrip()),
                        LINKTO='',
                        PARENT=None,
                        PARENTID=None,
                        LABEL=None,
                        RAW=line)

    IDs = set([str(i) for i in range(1000)][1:])
    def assignID(preNode,line,lineID, addenda, assignedIDs):
        if addenda: #CURRENTLY MUST BE MANUALLY INSERTED /ID ZERO
            IDfromAddenda = addenda.split('ID ')
            if len(IDfromAddenda)>1:
                lineID = IDfromAddenda[1].split(' ')[0]
        else:
            if lineID==-1 or (lineID in assignedIDs):
                lineID = list(IDs - assignedIDs)[0]
        # use lineID
        preNode['ID']= lineID
        assignedIDs.add(lineID)
        return preNode, assignedIDs

    def splice(preNodes):
        #global STARTING
        #if STARTING:
        #    STARTING=False
        #    return ''
        """interweave nodes and preNodes before sending to fillLeft"""
        #print('splice:', preNodes)
        newLines=[]
        newNodes=preNodes
        mergedNodes=[]

        oldNodes = {} #a dict of diagrammed nodes, indexed by ID, but now with upper case keys
        for node in pythonize(data['nodes'].get()):
            uppered={}
            for k,v in node.items():
                uppered[k.upper()] = v
            oldNodes[uppered['ID']] = uppered

        for newNode in newNodes:
            if newNode['ID'] in oldNodes: #merge new shorthand values into oldNode
                mergedNode = oldNodes[newNode['ID']] | newNode  #MERGE
                mergedNodes.append(mergedNode)
            else:
                mergedNodes.append(newNode)

        for mergedNode in mergedNodes:
            #print('mergedNode', mergedNode)
            newLine = niceRep(mergedNode, goodKeys='ID LABEL LINKTO TITLE COLOR SHAPE'.split(' '))
            newLine= newLine.replace('/','\n')
            newLines.append(newLine)
        return newLines

    lastKeyStroke=0
    def onShortHands(ev, FORCE=True):
        global lastKeyStroke, assignedIDs
        now = window.Date.now()
        if not FORCE:
            if  now - lastKeyStroke < 300:
                lastKeyStroke = now
                return
        lastKeyStroke = now

        assignedIDs = set()
        shortStrings = editor.getValue()
        lines=shortStrings.split('\n')

        preNodes = [newNode(line) for line in lines if line.strip()]
        # compute parents
        for i in range(len(preNodes)):
            my = preNodes[i]
            if i>0: #first guy has no parent
                for j in range(i+1):
                    if preNodes[i-j]['DEPTH'] < my['DEPTH']: #found parent
                        preNodes[i]['PARENT'] = preNodes[i-j]  #parents
                        break # We now know our parent

        for i,preNode in enumerate(preNodes):
            line=preNode['RAW']

            #### extract components for future use.
            if '/' in line: #split off addenda
                line, addenda = line[:line.find('/')], line[line.find('/')+1 :]
                addenda=addenda.strip()
            else:
                addenda = ''

            if ':' in line: #split off linktos
                line, linkto = line[:line.find(':')], line[line.find(':')+1 :]
                #linkto=linkto.split()
            else:
                linkto=''

            words = line.strip().split(' ')
            if len(words) == 1: #one word Labels become IDs
                lineID = words[0].strip()
            else:
                #### get this right
                #lineID = IDs.pop(0) #else assign an ID
                lineID = -1

                #preNode['ADDENDA']= '/ID ' + lineID

            #### use line and components carefully
            preNode['LABEL']=line.strip()

            if preNode['PARENT']:  #since parent precedes child, parent ID is available for use
                preNode['PARENTID'] = preNode['PARENT']['ID']

            ####assign ID and update assignedIDs
            preNode, assignedIDs = assignID(preNode,line,lineID, addenda, assignedIDs)

            #Linktos #aggregate linktos for when we get out of the loop
            if preNode['PARENT']:
                preNode['PARENT']['LINKTO'] += ' ' + preNode['ID'] #works
            if linkto:
                preNode['LINKTO'] += ' ' + linkto
            #preNode['ADDENDA'] = niceRep(preNode, goodKeys='ID LABEL LINKTO TITLE'.split(' '))

        linktos=set() #collect all the linktos for all the nodes
        for preNode in preNodes:
            for target in preNode['LINKTO'].split(' '):
                linktos.add(target)

        #collect all explicit IDs for all the  nodes
        namedNodes=set([node['ID']for node in preNodes])

        #create nodes that were mentioned in linktos but not explicitly named
        for ID in linktos-namedNodes: #the linktos that need to be named
            if ID:
                newPreNode = newNode(ID)
                newPreNode['ID']=ID
                newPreNode['LABEL']= ID
                preNodes.append(newPreNode)

        newLines= splice(preNodes)

        fillLEFT('\n\n'.join(newLines)) #newlines=mergeLeft(newLines)
        onEdit(ev) #parse LEFT pane

    def fillLEFT(src):
        global graphString
        document['LEFT'].html = '<br>'.join(src.split('\n'))
        graphString=src
    fillLEFT(graphString)

    """def onShortClick(ev):
        print('shortclick')
        nodes = getNodes(document['LEFT'].text)
        lines=[]
        for node in nodes:
            print(node)
            line=node['id']+ ':'
            if 'linkto' in node:
                line+=node['linkto']
            for k,v in node.items():
                line += '/' + k.upper() + ' ' + v
            lines.append(line)
        document['SHORTHANDS'].html= '<br>'.join(lines)"""


    def doSomething(ev,filter='nodes'):
        global options, data, network
        global graphString
        print('doSomething')
        print('PO', parseOptions(graphString))
        #options['nodes']['color']='blue'
        data, options, network = refreshGraph(graphString, modifiedOptions=options, modifiedData=data) #this will update options
        network.fit()
        network.on('configChange', configChange)
        network.on("click", networkClick)  #rebuilt network, so rebuild click


    def pythonize(ev):
        return JSON.parse(JSON.stringify(ev))

    def configChange(ev):
        global options
        print('configChange', JSON.stringify(ev))
        parsed = pythonize(ev) #JSON.parse(JSON.stringify(ev))  #
        for key in parsed: #there should actually be only one key
            options[key] = parsed[key]
            #this updates the global object. getOptions will persist them.

    def getOptions(ev):
        global data, options, graphString, network

        if ev.target.id == 'toggle':
            options['configure']['enabled'] = not options['configure']['enabled']
            if not options['configure']['enabled']:
                document['tweaker'].html='tweaker'

        if ev.target.id in 'physics nodes edges layout'.split():
            document['tweaker'].html='tweaker'
            options['configure']['enabled']=True
            options['configure']['filter'] = ev.target.id


        if ev.target.id == 'storePositions':
            parsed = pythonize(network.getPositions())# JSON.parse(JSON.stringify( network.getPositions()))
            nodes=pythonize(data['nodes'].get())
            for i,node in enumerate(nodes):
                id = node['id']
                node['x'] = parsed[id]['x']
                node['y'] = parsed[id]['y']
            lines=[]
            for N in nodes:
                for k,v in N.items():
                    if v:
                        lines.append((k.upper() +' '+ str(v)))
                lines.append('\n')
            fillLEFT('\n'.join(lines))
            network.storePositions() #This is needed.  (but why?)
            #options['manipulation']= { 'enabled': true } #this turns on interactive editing

        document['tweaker'].html='clear'
        data, options, network = refreshGraph(graphString, modifiedOptions=options, modifiedData=data) #this will update options
        print('physics', options['physics'])
        #if ev.target.id == 'storePositions':
        loadPositions(ev)
        network.fit()

        network.on('configChange', configChange)
        network.on("click", networkClick)  #rebuilt network, so rebuild click

    def loadPositions(ev):
        nodes = pythonize(data['nodes'].get())
        for node in nodes:
            data['nodes'].update(node)
        network.fit()
    document['loadPositions'].bind('click', loadPositions)

    document['SHORTHANDS'].bind('input', onShortHands)
    document['console'].bind('dblclick', doSomething)

    def fit(ev):
        global nework
        network.fit()
    document['Center'].bind('click', fit)

    for buttonID in 'physics nodes edges storePositions toggle layout'.split():
        document[buttonID].bind('click', getOptions)

    loadFileName(filename)

    </script>
</body>
</html>
