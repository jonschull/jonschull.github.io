<html>
<head>
    <script type="text/javascript"  src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script type="text/javascript"  src="https://cdn.jsdelivr.net/npm/brython@3.9.0/brython.min.js">     </script>
    <script type="text/javascript"  src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.8.8/brython_stdlib.js"></script>

    <style type="text/css">
        #mynetwork {
            width: 100%;
            height: 800px;
        }
        table,td,th{
            border: 1px solid black;
        }
        td{
            width:50%
        }
        body {
            margin: 0;            /* Reset default margin */
        }
        iframe {
            display: block;       /* iframes are inline by default */
            background: #000;
            border: none;         /* Reset default border */
            height: 100vh;        /* Viewport-relative units */
            width: 100vw;
        }
    </style>

</head>
<body onload="brython()">
    <script type="text/python">
    from browser import document,html,aio, window
    from javascript import JSON
    from browser.html import *

    ### error box for print()
    errorBox = DIV(PRE(ID='console'))
    document<=errorBox
    import sys
    class MyOutput:
        def __init__(self):
            self.console = document["console"]
        def write(self, text):
            self.console.html +=  text + '</hr>'
    sys.stdout = MyOutput()
    sys.stderr = MyOutput()

    document <= TABLE(  TR( TH('Text')+ TH('Diagram')) +
                        TR( TD('Text goes here!!!',ID='LEFT', contenteditable='true') + TR(DIV('goes here', id="mynetwork"))))

    ### just an illustration. these are overridden
    nodes =[dict(id="1.1", label='1'), dict(id=2, label='2')]
    edges = [{'from':"1.1", 'to': 2}]


    graphString=open('graphstring.txt').read() #this only works from server

    document['LEFT'].html = '<pre>' + graphString + '</pre>'


    def getNodes(graphString=graphString):
        keywords = 'ID LABEL URL TITLE LINKTO'.split()

        goodLines = []
        for line in graphString.split('\n'):
            line=line.strip()
            if line.strip():             #keep non-blank lines
                goodLines.append(line)
            else:                        #throw out the other
                goodLines.append('BREAK\n')
        goodLines = '\n'.join(goodLines).split('BREAK\n')                    #make a string
        chunks = [line.strip() for line in goodLines if line.strip()]        #split it at the BREAKs to make a chunk that will become a record

        #break each chunk at keyword to create records
        records = []
        for chunk in chunks:
            for keyword in keywords:
                chunk=chunk.replace('\n'+ keyword,'BREAK'+ keyword)
            lines=chunk.split('BREAK')
            records.append([line.strip() for line in lines if line.strip()])
        records

        # convert records into nodes
        nodes = []
        for record in records:
            node = dict()
            for line in record:
                key = line.split()[0].lower()
                value = ' '.join(line.split(' ')[1:]).strip()
                node[key] = value
            nodes.append(node)

        return(nodes)

    def getEdges(nodes):
            edges = []#[{'from':'1', 'to':'2'}]
            for node in nodes:
                if 'linkto' in node.keys():
                    links = node['linkto'].split()
                    for link in links:
                        edges.append({'from':node['id'],
                                       'to': link})
            return edges

    nodes = getNodes()
    edges = getEdges(nodes)
    data = {'nodes':nodes, 'edges': edges}
    options = { "physics":{"enabled":True
                          },
                "layout":{  "improvedLayout": True},
                    "edges":{"smooth": True,
                             "arrows":{"to":True}
                             },
                     "nodes":{"shape":"box",
                              "font" :"14px"
                             }
                 };

    network = window.vis.Network.new(document['mynetwork'], data, options)

    def networkClick(params): #bound via network.on below
        print('networkClick', params.nodes)
        ID=params.nodes[0]
        URL = [node['url'] for node in nodes if node['id'] == ID][0]
        document['LEFT'].html = URL; # for a moment,
        aio.run(showFile(URL))       # until this finishes

    async def showFile(src): #works locally and via server
        # Text file
        req = await aio.ajax("GET", src)
        content = JSON.parse(req.data)['content']
        document['LEFT'].html = content

    network.on("click", networkClick);

    # document.query
    # is straightforward but to load the query as graphstring,
    # I'll need to make an async main?

    </script>

</body>
</html>
