<html>
<head>
    <script type="text/javascript"  src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script type="text/javascript"  src="https://cdn.jsdelivr.net/npm/brython@3.9.0/brython.min.js">     </script>
    <script type="text/javascript"  src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.8.8/brython_stdlib.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.min.js" type="text/javascript" charset="utf-8"></script>
    <link rel="stylesheet" href="splicerStyles.css">
</head>
<body onload="brython()">
    <script type="text/python">
    from browser import document, html, aio, window, load
    from browser.local_storage import storage
    from javascript import JSON
    from browser.html import *

    #filename and graphString are GLOBAL
    #...index.html?filename=whatever
    def fileStart():
        global filename, graphString
        filename = document.query.getfirst('filename')
        if not filename:
            filename='graphString.txt'
        if filename in storage:
            graphString = storage[filename]
            print('loaded', filename)
        else: #save default graphString.txt as under filename
            graphString=open('graphString.txt').read() #this only works from server
            print('using default remote graphString.txt')
    fileStart()

    ### print and errors will go to console (unless Brython fails)
    def redirectOutputs():
        document <= DIV(PRE(ID='console',  contenteditable='true'))
        import sys
        class MyOutput:
            def __init__(self):
                self.console = document["console"]
            def write(self, text):
                self.console.html +=  text + '</hr>'
        sys.stdout = MyOutput()
        sys.stderr = MyOutput()
    redirectOutputs()

    document <= TABLE(  TR( TH('ShortHands')
                            +TH('Filename '
                                + INPUT(filename, id='filename', value=filename)
                                + BUTTON('Save', id='Save')
                                + SPAN(id='status')
                                + BUTTON('Load', id='Load') )
                            +TH('Diagram'))
                        +TR (TD('Shorthands!!!',ID='SHORTHANDS', contenteditable='true')
                            +TD('Text goes here!!!',ID='LEFT', contenteditable='true')
                            +TD(DIV('goes here', id="mynetwork"))))

    window.ace.config.set('basePath', 'https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/');
    editor = window.ace.edit("SHORTHANDS");
    editor.setOptions({
            'showLineNumbers':False,
            'showInvisibles': True,
            'useSoftTabs': False})
    editor.session.setMode("ace/mode/yaml");

    #print('Available files:\n', [key for key in storage if not key.endswith('.short')] )

    def loadFileName(ev):
        global filename
        filename = document['filename'].value
        if not filename in storage:
            print('AVAILABLE FILES', [key for key in storage if not key.endswith('.short')])
            return

        graphString = storage[filename]
        fillLEFT(graphString)

        ####NEW AND UNTESTED
        if filename + '.short' in storage:
            shortHands= storage[filename + '.short']
            editor.setValue(shortHands)

        document['status'].text = '  loaded'
        onEdit(ev)
    document['Load'].bind('click', loadFileName)

    def saveFileName(ev):
        global filename
        filename = document['filename'].value
        graphString=document['LEFT'].text ;   storage[filename] = graphString
        shortHands = editor.getValue()    ;  storage[filename+'.short'] = shortHands

        document['status'].text = '  saved'
    document['Save'].bind('click', saveFileName)

    from imports.nodeStuff import dataAndOptions, getNodes


    def refreshGraph(graphString):
        data, options = dataAndOptions(graphString)
        network = window.vis.Network.new(document['mynetwork'], data, options)
        return (data, options, network)
    data, options, network = refreshGraph(graphString)


    def networkClick(params): #bound via network.on below
        print('networkClick', params.nodes)
        if params.nodes:
            ID=params.nodes[0]
            URL = [node['url'] for node in nodes if node['id'] == ID][0]
            print('URL', URL)
            if URL:
                document['LEFT'].html = URL; # for a moment,
                aio.run(showFile(URL))       # until this finishes
    network.on("click", networkClick);

    async def showFile(src): #works locally and via server
        # Text file
        req = await aio.ajax("GET", src)
        print(src, req.statusText)
        if req.statusText == 'OK':
            content = JSON.parse(req.data)['content']
            #document['LEFT'].html = content
            fillLEFT(content)

    def onEdit(ev):
        global data
        document['status'].text = 'changed'
        graphString = document['LEFT'].text
        data, options, network = refreshGraph(graphString)
        network.on("click", networkClick)  #rebuilt network, so rebuild click
    document['LEFT'].bind('input',onEdit)

    def niceRep(preNode, goodKeys = 'ID LABEL LINKTO PARENT ADDENDA'.split(' ')):
        ret=[]
        for k,v in preNode.items():
            if k in goodKeys:
                ret.append(f'{k} {v}')
        return '/' + '  /'.join(ret)

    def newNode(line):
        return dict( ID=None,
                        DEPTH = len(line) - len(line.lstrip()),
                        LINKTO='',
                        PARENT=None,
                        PARENTID=None,
                        LABEL=None,
                        RAW=line)

    IDs = set([str(i) for i in range(1000)][1:])
    def assignID(preNode,line,lineID, addenda, assignedIDs):
        if addenda: #CURRENTLY MUST BE MANUALLY INSERTED /ID ZERO
            IDfromAddenda = addenda.split('ID ')
            if len(IDfromAddenda)>1:
                lineID = IDfromAddenda[1].split(' ')[0]
        else:
            if lineID in assignedIDs:
                lineID = list(IDs - set(assignedIDs))[0]
        # use lineID
        preNode['ID']= lineID
        assignedIDs.append(lineID)
        return preNode, assignedIDs

    def splice(preNodes):
        """interweave nodes and preNodes before sending to fillLeft
        NOT YET"""
        newLines=[]
        newNodes=preNodes
        mergedNodes=[]

        oldNodes = {} #a dict of diagrammed nodes, indexed by ID, but now with upper case keys
        for node in data['nodes']:
            uppered={}
            for k,v in node.items():
                uppered[k.upper()] = v
            oldNodes[uppered['ID']] = uppered

        for newNode in newNodes:
            if newNode['ID'] in oldNodes: #merge new shorthand values into oldNode
                mergedNode = oldNodes[newNode['ID']] | newNode  #MERGE
                mergedNodes.append(mergedNode)
            else:
                mergedNodes.append(newNode)

        ### note:  what this fails to do is preserve nodes created in LEFT

        for mergedNode in mergedNodes:
            print('mergedNode', mergedNode)
            newLine = niceRep(mergedNode, goodKeys='ID LABEL LINKTO TITLE COLOR SHAPE'.split(' '))
            newLine= newLine.replace('/','\n')
            newLines.append(newLine)
        return newLines

    lastKeyStroke=0
    def onShortHands(ev):
        global lastKeyStroke
        now = window.Date.now()
        if now - lastKeyStroke < 300:
            lastKeyStroke = now
            return
        lastKeyStroke = now

        assignedIDs = []
        shortStrings = editor.getValue()
        lines=shortStrings.split('\n')

        preNodes = [newNode(line) for line in lines if line.strip()]
        # compute parents
        for i in range(len(preNodes)):
            my = preNodes[i]
            if i>0: #first guy has no parent
                for j in range(i+1):
                    if preNodes[i-j]['DEPTH'] < my['DEPTH']: #found parent
                        preNodes[i]['PARENT'] = preNodes[i-j]  #parents
                        break # We now know our parent

        print()
        for i,preNode in enumerate(preNodes):
            line=preNode['RAW']

            #line, linkto, lineID

            #### extract components for future use. TODO could be function
            if '/' in line: #split off addenda
                line, addenda = line[:line.find('/')], line[line.find('/')+1 :]
                addenda=addenda.strip()
            else:
                addenda = ''

            if ':' in line: #split off linktos
                line, linkto = line[:line.find(':')], line[line.find(':')+1 :]
                #linkto=linkto.split()
            else:
                linkto=''

            words = line.strip().split(' ')
            if len(words) == 1: #one word Labels become IDs
                lineID = words[0].strip()
            else:
                lineID = IDs.pop(0) #else assign an ID
                #preNode['ADDENDA']= '/ID ' + lineID

            #### use line and components carefully
            preNode['LABEL']=line.strip()

            if preNode['PARENT']:  #since parent precedes child, parent ID is available for use
                preNode['PARENTID'] = preNode['PARENT']['ID']

            ####assign ID and update assignedIDs
            preNode, assignedIDs = assignID(preNode,line,lineID, addenda, assignedIDs)

            #Linktos #aggregate linktos for when we get out of the loop
            if preNode['PARENT']:
                preNode['PARENT']['LINKTO'] += ' ' + preNode['ID'] #works
            if linkto:
                preNode['LINKTO'] += ' ' + linkto
            #preNode['ADDENDA'] = niceRep(preNode, goodKeys='ID LABEL LINKTO TITLE'.split(' '))

        linktos=set() #collect all the linktos for all the nodes
        for preNode in preNodes:
            for target in preNode['LINKTO'].split(' '):
                linktos.add(target)

        #collect all explicit IDs for all the  nodes
        namedNodes=set([node['ID']for node in preNodes])

        #create nodes that were mentioned in linktos but not explicitly named
        for ID in linktos-namedNodes: #the linktos that need to be named
            if ID:
                newPreNode = newNode(ID)
                newPreNode['ID']=ID
                newPreNode['LABEL']= ID
                preNodes.append(newPreNode)

        newLines= splice(preNodes)

        fillLEFT('\n\n'.join(newLines)) #newlines=mergeLeft(newLines)
        onEdit(ev) #refresh LEFT pane

    def fillLEFT(src):
        document['LEFT'].html = '<br>'.join(src.split('\n'))
    fillLEFT(graphString)

    def onShortClick(ev):
        print('shortclick')
        nodes = getNodes(document['LEFT'].text)
        lines=[]
        for node in nodes:
            print(node)
            line=node['id']+ ':'
            if 'linkto' in node:
                line+=node['linkto']
            for k,v in node.items():
                line += '/' + k.upper() + ' ' + v
            lines.append(line)
        document['SHORTHANDS'].html= '<br>'.join(lines)


    document['SHORTHANDS'].bind('input', onShortHands)
    #document['SHORTHANDS'].bind('dblclick', onShortClick)

    </script>
</body>
</html>
